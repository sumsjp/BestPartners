好的，這是經過整理後的文稿，我將其分成了更易於閱讀的段落，並添加了小標題以方便理解：

**標題：最佳拍檔：Agent 的 12 個設計原則，助你填平落地鴻溝**

**開場**

大家好，这里是最佳拍档，我是大飞。AI 行業的朋友都會有一個感覺，那就是 Agent 正在從概念走向落地。只不過讓它從“能跑起來”，到“能穩定用起來”，中間還隔著一道巨大的鴻溝。今天我想和大家聊的“12-Factor Agents”，翻譯過來就是 Agent 的十二個設計原則，就是為了填平這道鴻溝而生的。正好前幾天也有觀眾在評論區提到了它。

**12-Factor Agents 的本質**

需要說明的是，這套原則不是一個像 LangChain 這樣可以直接拿來用的“工具箱”，而是一套“方法論”，就像多年前軟件開發領域的“12-Factor App”原則一樣。它把傳統軟件工程裡經過驗證的最佳實踐，創造性地用到了大模型驅動的 Agent 開發裡。它的核心目標也很明確，那就是彌補 Agent 從原型開發到生產級應用的鴻溝，讓 Agent 在可靠性、可伸缩性、可维护性、可调试性和安全性上，達到企業級應用的標準。

**項目背景：HumanLayer 和 Dexter Horthy**

在詳細介紹這十二個原則之前，我們還要稍微花點時間介紹一些跟這個項目有關的背景。12-Factor Agents 項目 的發起者是一家叫 HumanLayer 的舊金山創業公司，創始人是德克斯特·霍西（Dexter Horthy）。他的經歷很有意思，17 歲就開始在 NASA 噴氣推進實驗室編程，後來在開發工具公司 Replicated 待了 7 年，從工程師做到產品經理再到高管，幫 Hashicorp、DataStax 這些知名企業交付過本地 K8s 產品。這段經歷讓他對“生產級系統”的嚴謹性有著極深的理解，因為分布式系統的可靠性以及容器編排的可擴展性，這些都是他多年來每天要面對的問題。

**Agent 的痛點：Human-in-the-Loop**

真正讓他轉向 Agent 領域的是 2023 年的一個項目。當時他正在構建一個基於 Slack 的 Agent，想用來管理 SQL 数据库。在开发过程中，他发现了一个被很多人忽视的关键问题，那就是 Agent 在执行任务的时候，怎么才能有效地把人类“拉进来”呢？比如，当 Agent 需要执行一条可能影响生产数据的 SQL 语句时，它不能自己做主，得让人类审核同意。但是传统的 Agent 设计，都是让人类坐在屏幕前等 AI 说话，AI 不会主动找人类要反馈。这个“Human-in-the-Loop（人类在环）”的痛点不仅让他成立了 HumanLayer，更是直接催生了 12-Factor Agents 的核心理念。而霍西的願景，就是要推動 Agent 從人機問答聊天的“第一代”，以及由框架驅動的“第二代”，進化到“第三代”自主 Agent，能自己做的事情自己做，做不了的事及時找人類幫忙，既高效又安全。

**12-Factor Agents 項目簡介**

講完背景，我們來看看 12-Factor Agents 這個項目本身。目前它在 GitHub 上有 13.8k 星標、978 個 fork。它的代碼主要用 TypeScript 寫的，還有少量的 Python。整個項目最核心的創新是它提出的“反框架”理念。和傳統框架不一樣，它不提供“黑盒式”的解決方案，而是堅持讓開發者“完全控制核心組件”。

**為什麼要“反框架”？**

因為在企業級應用裡，透明度、可調試性、可維護性比“開發快”更加重要。比如一個金融領域的 Agent，開發者必須知道每一步的邏輯是什麼、數據流向哪裡，不能把核心邏輯都交給框架的黑盒。

**12 個設計原則逐一拆解**

接下来，我们就来逐个拆解它的 12 个设计原则。这是项目的核心，每个原则都对应着生产级 Agent 的一个关键需求，我会尽量讲清楚它是什么，为什么重要以及怎么落地。

**原則 1：自然語言到工具調用 (Natural Language to Tool Calls)**

這個原則的核心是，Agent 的核心能力應該是把人類的自然語言指令準確轉換成結構化的工具調用。不是讓 Agent 直接“回答問題”，而是讓它在理解問題後能夠調用合適的工具去解決問題。比如，用戶說“幫我查一下上個月的銷售總額，然後生成一個 Excel 報表”，Agent 不能直接輸出數字，而是要先把這句話轉換成兩個結構化的工具調用：

1.  調用“銷售數據查詢工具”，參數是“時間範圍：上個月”
2.  調用“Excel 生成工具”，參數是“數據來源：銷售數據查詢結果”

**為什麼重要？**

因為自然語言是模糊的，但是工具調用是精確的。結構化的工具調用能夠讓 Agent 的行為變得“可預測”，也方便開發者調試。比如如果 Agent 沒生成報表，開發者可以查一下“是不是工具調用的參數錯了”，而不是去猜“是不是 Agent 沒有理解自然語言”。

**如何落地？**

關鍵是設計清晰的工具接口。每個工具的功能是什麼、需要哪些參數、返回什麼結果，都要定義得清清楚楚。比如“銷售數據查詢工具”，要明確參數包括哪些必填項和可選項，返回結果又包括哪些字段，這樣大語言模型才能準確的調用。

**原則 2：擁有你的提示詞 (Own your prompts)**

提示詞是大模型應用的“靈魂”，但是很多框架會把提示詞藏在內部。比如 LangChain，你調用的時候看不到它給模型發了什麼提示詞。所以這個原則就是要強調，開發者必須能完全控制提示詞的設計、修改和版本管理。

**為什麼要“擁有提示詞”？**

因為不同業務場景需要不同的提示詞。比如同樣是客服 Agent，賣電子產品的和賣服裝的，提示詞的語氣、需要包含的產品知識都不一樣。如果提示詞藏在框架裡，開發者沒法根據業務需求來調整，Agent 的效果就會打折扣。另外，生產環境裡，提示詞的版本管理也很重要。比如你修改了提示詞後 Agent 的準確率下降了，這時候需要能回滾到之前的版本。如果提示詞在框架裡，你根本沒法做版本控制。

**如何落地？**

建議大家把提示詞當成“代碼”一樣管理，把它存在代碼倉庫裡，做版本控制，還可以做 A/B 測試。比如同時用兩個版本的提示詞，看哪個讓 Agent 的工具調用準確率更高，再選擇效果好的那個。

**原則 3：擁有你的上下文窗口 (Own your context window)**

大模型的上下文窗口長度是有限的，怎麼管理上下文會直接影響到 Agent 的性能。這個原則的核心是框架不能替你來決定哪些內容要留在上下文裡，哪些要刪掉，開發者要自己控制上下文窗口的管理邏輯。

**例子**

比如，一個處理長對話的 Agent，用戶聊了半小時，上下文窗口快滿了，這時候該刪什麼？是刪最早的對話，還是刪重複的信息，還是刪不重要的細節呢？不同場景的答案是不一樣的。如果是客服對話，可能需要保留用戶的核心訴求（比如“要退款”），刪掉其他無關的閒聊；如果是技術支持對話，可能需要保留之前提到的报错信息，删掉无关的产品介绍。如果框架替你做了決策，比如默認刪最早的對話，就可能會導致 Agent 忘記用戶的核心訴求，進而做出錯誤的判斷。

**如何落地？**

所以开发者必须自己来设计上下文的管理逻辑，比如基于“信息的重要性”排序，优先保留关键的信息，删掉次要的信息。

需要开发者定义一个信息重要性的评分标准。比如用户的需求、系统的关键参数、工具调用的结果这些是高重要性的，要保留；用户的礼貌用语、重复的提问这些是低重要性，可以删除。

**原則 4：工具只是結構化輸出 (Tools are just structured outputs)**

這個原則有點反直覺，它把“工具調用”理解成模型的一種結構化輸出，而不是“Agent 去調用一個外部工具”。比如模型輸出的不是“我要調用銷售數據查詢工具”，而是一個 JSON 格式的結構化數據。

**為什麼要這麼理解？**

因為這能簡化系統的架構。Agent 不需要“知道怎麼調用工具”，只需要“輸出結構化的工具調用指令”，然後由專門的“工具執行模塊”去解析這個指令調用對應的工具。這樣一來 Agent 的邏輯和工具執行的邏輯就分開了，更加容易維護。

比如如果“銷售數據查詢工具”的接口變了，開發者只需要修改“工具執行模塊”的代碼，不用去改 Agent 的邏輯。如果要新增一個工具，也只需要在“工具執行模塊”裡增加一個新的工具實現，Agent 只需要輸出對應的結構化指令就行。

**如何落地？**

关键是统一工具的调用格式。比如所有的工具调用都用 JSON 格式，包含工具名和参数两个字段，这样“工具执行模块”就能用统一的逻辑来解析。

**原則 5：統一執行狀態和業務狀態 (Unify execution state and business state)**

在傳統的 Agent 設計裡，執行狀態（比如“正在調用工具”或者“等待用戶反饋”）和業務狀態（比如“用戶的訂單號”或者“銷售數據查詢結果”）這兩塊基本都是分開管理的。執行狀態存在 Agent 的內存裡，業務狀態存在數據庫裡。這樣很容易出現“狀態不一致”的問題。比如 Agent 以為自己已經調用了工具，但是實際上工具調用失敗了，業務狀態沒更新，導致 Agent 後續的行為出錯。

**核心**

这个原则的核心是把执行状态和业务状态放在一起来管理，形成一个统一的“全局状态”。比如全局状态里既包含当前步骤等待工具返回结果这样的执行状态，也包含工具调用参数为时间范围等于上个月的业务状态，还有工具返回结果为销售额 100 万这样的业务状态。

**好處**

这样做的好处是，一旦 Agent 出错，比如说进程崩溃了，重启后就可以从全局状态里恢复，因为它知道自己之前执行到哪一步了，有哪些参数和结果，所以不用重新开始。比如 Agent 在调用工具后崩溃了，重启后通过查看全局状态，发现已经调用了工具，但是还没处理结果，就可以直接去拿工具的返回结果，继续执行后续步骤。

**如何落地？**

建议用一个专门的状态存储服务，比如 Redis 或者其他数据库来管理全局状态。每个 Agent 任务都有一个唯一的 ID，通过 ID 来查询对应的全局状态。

**原則 6：使用簡單的 API 來完成啟動、暫停和恢復 (Launch/Pause/Resume with simple APIs)**

在生產環境裡，Agent 可能需要一些處理長時間運行的任務。比如生成一份年度銷售報告，可能就需要調用多個工具、處理大量的数据，耗时几个小时。这时候，如果需要暂停任务或者任务失败后要进行恢复，就需要简单的 API 来操作。

**核心**

这个原则的核心是 Agent 的启动、暂停、恢复都应该通过简单的 API 来实现，而不是通过修改代码或者配置。比如调用“POST /agent/start”来启动任务，调用“POST /agent/pause?task_id=xxx”来暂停任务。

**為什麼需要簡單 API？**

因为在生产环境里，这些操作可能会由运维人员通过自动化工具来执行，而不是开发者手动操作的。比如系统维护的时候，运维工具可以批量调用“暂停 API”，暂停所有正在运行的 Agent 任务；等维护结束后，再批量调用“恢复 API”，让任务继续执行。

**如何落地？**

需要设计符合 RESTful 风格的 API，明确每个 API 的参数、返回值、错误处理逻辑。比如对于“暂停 API”来说，如果任务已经暂停，那么可以返回“400 Bad Request”，并且提示“任务已经处于暂停状态”。

**原則 7：通過工具調用來聯繫人類 (Contact humans with tool calls)**

這是 12 個原則裡最有創新性的一个，它的核心是讓 Agent 通過“調用人類工具”的方式主動聯繫人類獲取反饋，而不是等人類主動找它。这里的“人类工具”，可以理解成一个专门用来和人类交互的工具，比如“发送审批通知工具”“获取人类反馈工具”。

**例子**

比如 Agent 要执行一条修改生产数据库的 SQL 语句，它会先调用“发送审批通知工具”，参数是“审批内容：执行 SQL 语句 xxx 审批人：数据库管理员”；数据库管理员通过审批之后，Agent 会调用“获取人类反馈工具”，拿到“审批通过”的结果再执行 SQL 语句。

传统的人机交互是“从人类到 AI”，而这个原则把它变成了“从 AI 到人类”，让 Agent 主动发起交互，人类来被动响应。这种方式特别适合生产环境，因为人类不用时刻盯着 Agent，Agent 只有在需要的时候才会去找人类，既高效又安全。

**如何落地？**

需要设计专门的“人类交互工具”，比如集成企业微信、Slack、邮件等通知渠道，让 Agent 可以通过这些渠道联系到人类；同时设计一些反馈收集机制，比如人类点击通知里的“同意或拒绝”按钮后反馈结果能够自动回到 agent 的全局状态里。

**原則 8：擁有你的控制流 (Own your control flow)**

控制流就是 agent 的执行逻辑，比如说先调用工具 a，再根据工具 a 的结果决定调用工具 b 还是工具 c。这个原则的核心是开发者必须完全控制控制流，不能让框架替你来决定执行的逻辑。

**情況**

很多框架会提供一些预定义的控制流，比如“顺序执行链”或者“条件分支链”，但是企业级应用的控制流往往很复杂。比如一个供应链 Agent，需要先调用“库存查询工具”，如果库存充足，再调用“发货工具”；如果库存不足，则调用“采购工具”，采购完成后再调用“发货工具”，中间还要考虑采购失败的情况，这时候可能还需要调用“通知采购经理工具”。如果采用框架的预定义控制流，很难覆盖这么复杂的逻辑，就算能覆盖，后续修改起来也很麻烦。

**如何落地？**

所以开发者必须自己来设计控制流，比如用代码写清楚“每一步该做什么，遇到什么情况该怎么处理”。

建议采用“状态机”的思想来设计控制流，每个状态对应 Agent 的一个执行步骤，状态之间的转换由“条件”触发。比如“库存查询完成”状态，转换条件包括“从库存充足到发货状态”，或者从“库存不足到采购状态”，以及从“查询失败到重试状态”。

**原則 9：將錯誤壓縮到上下文窗口 (Compact Errors into Context Window)**

Agent 在生产环境里一定会出错，比如工具调用失败、模型返回错误信息、参数格式不对等等。这个原则的核心是把错误信息以紧凑的形式放进模型的上下文窗口里，让模型能根据错误信息来调整行为。

**例子**

Agent 调用“销售数据查询工具”的时候，如果因为参数“时间范围”的格式写错了，工具就会返回错误，提示参数的时间范围必须符合日期的格式。这时候 Agent 要把这个错误信息压缩后放进上下文窗口中，再让模型重新生成工具调用，而模型看到错误信息后就会把错误的日期格式改成正确的日期格式。

**为什么要“压缩”错误信息呢？**

因为上下文窗口的长度是有限的，如果错误信息太长（比如几百行的堆栈信息）就会占用大量的窗口空间，导致其他的重要信息被删掉。所以需要把错误信息提炼成“关键信息”，比如包括错误类型、错误原因、解决方案的提示等等。

**如何落地？**

需要设计错误信息的压缩逻辑，比如提取错误类型、错误来源、错误原因、修复建议，再去掉无关的堆栈信息、日志 ID 等等。

**原則 10：小而專注的 Agent (Small Focused Agents)**

这个原则借鉴了微服务的思想。不要做一个“无所不能”的超级 Agent，而是做多个“小而专注”的 Agent，每个 Agent 只负责一个特定的任务域。比如，不要做一个“企业管理 Agent”，而是拆成“销售数据 Agent”（负责查询、分析销售数据）、“库存管理 Agent”（负责查询库存、触发采购）、“客服 Agent”（负责处理客户咨询）。每个 Agent 只关注自己的任务域，这样逻辑更加简单，维护也更加方便。

**为什么“小而专注”？**

因为超级 Agent 的逻辑太复杂，容易出错，也难以调试。比如一个超级 Agent 既能处理销售数据，又能处理库存，还能处理客服，一旦出了问题，开发者要在几百行代码里找原因；而小的 Agent 出了问题，只需要看对应任务域的代码，效率会高很多。另外，小的 Agent 还方便团队分工，你可以让销售团队来负责维护“销售数据 Agent”，库存团队来负责维护“库存管理 Agent”，不用所有的人都盯着一个超级 Agent。

**如何落地？**

关键是要做到“任务域的拆分”，根据业务模块、职责范围来拆分 Agent。每个 Agent 的输入、输出、工具调用都要明确，避免功能重叠。比如“销售数据 Agent”的输出是“销售报表”，“库存管理 Agent”的输入是“销售报表”，两者通过结构化的数据交互，不用共享内部逻辑。

**原則 11：從任何地方觸發 (Trigger from anywhere)**

企业里的系统是多种多样的，有像 Slack、企业微信这样的沟通工具，也有 CRM、ERP 这样的业务系统，还有定时任务、webhook 这样的自动化工具。这个原则的核心是 Agent 应该能从任何这些地方触发，而不是只能从某个固定的界面触发。

**例子**

比如“销售数据 Agent”可以被这几种方式触发：

*   一是运营人员在 Slack 里发出“查询上月销售数据”的消息；
*   二是 CRM 系统里当新的订单超过 100 万的时候自动触发 Agent 生成报表；
*   三是每周一早上 8 点定时任务触发 Agent 生成周报表。

**为什么“从任何地方触发”？**

因为这样才能让 Agent“融入”到企业的现有工作流里，而不是让员工去“适应”Agent。比如运营人员习惯用 Slack 工作，就不用特意打开 Agent 的界面，在 Slack 里就能触发任务。业务系统有事件发生的时候，Agent 也能自动响应，不用人工干预。

**如何落地？**

需要设计所谓的“触发适配器”，针对不同的触发来源开发对应的适配器。比如 Slack 适配器负责监听 Slack 的消息，解析出触发指令；CRM 适配器负责监听 CRM 的事件触发 Agent；定时任务适配器负责按时间来触发 Agent。每个适配器的输出都应该是统一的“触发指令”，这样 Agent 不用关心指令来自哪里。

**原則 12：讓你的 Agent 成為無狀態的歸約器 (Make your agent a stateless reducer)**

这个原则借鉴了函数式编程里的“归约器（reducer）”的概念，也就是 Agent 本身是无状态的，它的行为只由“当前的输入”和“外部的状态”所决定，不依赖内部存储的状态。“归约器”的逻辑是接收“当前状态”和“输入”，处理后输出“新的状态”。

**例子**

比如 Agent 接收的“当前状态”是已经调用销售数据查询工具但是没有生成报表，输入是销售数据查询结果为 100 万，处理后输出的新状态是已经生成报表，等待发送给运营人员。

**为什么要做到“无状态”？**

因为无状态的 Agent 更容易扩展。比如当有 100 个用户同时触发销售数据 Agent 的时候，服务器可以启动 100 个 Agent 实例，每个实例处理一个用户的任务，不用共享状态；如果某个实例崩溃了，其他实例也不受影响，新的实例可以从外部状态里恢复任务。

**如何落地？**

关键是把所有状态都放在外部存储里，Agent 只负责处理输入，生成新的状态，不自己保存任何状态。比如 Agent 处理任务的时候，先从外部存储获取当前状态，处理后再把新状态写回外部存储，然后就可以释放资源，下次处理的时候再重新获取状态。

**12 條原則的相互關係**

这 12 个原则不是孤立的，而是相互配合的。比如原则 12“无状态归约器”，需要原则 5“统一执行状态和业务状态”来支撑；原则 11“从任何地方触发”需要原则 1“自然语言到工具调用”来保证指令的统一；原则 7“通过工具调用联系人类”需要原则 10“小而专注的 Agent”来降低交互复杂度。它们共同构成了一套完整的生产级 Agent 设计体系，解决了可靠性、可扩展性、可维护性等核心问题。

**12-Factor Agents 與 LangChain、LlamaIndex、AutoGen 的關係**

很多朋友可能会问，有了 LangChain、LlamaIndex、AutoGen 这些框架，为什么还需要 12-Factor Agents 呢？这里需要明确一点的是，它们不是竞争关系，而是一种互补关系。12-Factor Agents 是“设计原则”，框架是“实现工具”，原则可以用来指导工具的使用。简单来说，12-Factor Agents 是球队的“教练”，告诉队员们“怎么打才能赢”，而框架是“球员”，负责执行具体的战术。比如，你可以用 LangChain 来搭建 Agent，但是要遵循 12-Factor Agents 的原则，自己控制提示词（原则 2）、自己管理上下文窗口（原则 3）、统一状态管理（原则 5）等等，这样搭建出来的 Agent 才能符合生产级的标准。所以 12-Factor Agents 不是要取代任何框架，而是要让框架的价值最大化。很多开发者用框架做原型很顺手，但是一到生产环境就出问题，本质上是因为没遵循工程化的原则，而 12-Factor Agents 就是要填补这个空白，让框架从“原型工具”变成“生产工具”。

**開發者應有的思維轉變**

對於從事 Agent 開發的朋友，12-Factor Agents 的啟發不只是技術層面的，更多是思維層面的：

1.  **設計思維的轉變：** 從“追求快速原型”轉向“注重生產質量”。以前我們可能覺得“先跑起來再說”，但是現在要意識到生產環境裡，“穩定”比“快”更重要。前期多花時間設計提示詞、控制流、狀態管理，後期能省很多调试的時間。
2.  **架構意識的提升：** 不要只關注模型的調參、提示詞的優化，還要關注系統架構。比如狀態怎麼存儲、工具怎麼解耦、錯誤怎麼恢復，這些架構層面的問題才是決定 Agent 是否落地的關鍵。
3.  **用戶體驗的創新：** 不要局限於“聊天界面”的交互模式，要思考“Agent 怎麼能主動融入用戶的工作流”。比如，用戶在處理訂單的時候，Agent 主動提示“這個客戶有退款記錄需要注意”；用戶在寫報告的時候，Agent 主動調用數據工具提供最新的銷售數據。這種“主動協作”的體驗才是 Agent 的核心價值。
4.  **跨學科整合：** Agent 開發不是純 AI 的工作，而是需要結合分布式系統、DevOps、產品設計等多個領域的知識。比如分布式系統的“無狀態設計”和“容錯機制”能夠幫助 Agent 實現高可用，而 DevOps 中的“CI/CD”和“監控告警”能夠幫助 Agent 實現快速迭代和穩定運行，包括產品設計裡的“用戶旅程”也能幫 Agent 設計更友好的人機交互。

**結語**

最后，我想引用 HumanLayer 的一句话，那就是不要重复传统软件开发早期的弯路，而是从一开始就建立良好的工程文化和设计原则。Agent 是 AI 落地的重要的載體，而 12-Factor Agents 就是帮助我们把 Agent 做“好”、做“稳”的关键一步。希望今天的内容能够给正在开发 Agent 的朋友带来一些启发。感谢大家观看本期视频，我们下期再见！

**總結：**

*   **清晰的標題和分段:** 方便讀者快速瞭解內容結構和重點。
*   **重點強調:** 使用粗體字突顯關鍵概念和結論。
*   **例子說明:** 使用具體例子來說明抽象的概念，幫助理解。
*   **排版優化:** 適當的空格和換行，讓文稿更易於閱讀。

希望這個整理後的文稿對您有幫助！

[model=gemini-2.0-flash,0]
