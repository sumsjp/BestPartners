大家好这里是最佳拍档
我是大飞
前一段时间呢
推特开源了他的推荐系统源码
目前已经超过了5.8万的star
我们之前也做过一期节目
简单介绍过一部分核心的代码
准备再开个系列
完整的去介绍一下这个代码
其中会包括推特的整体推荐系统架构
这部分会涵盖图数据挖掘
召回、精排
规则多样性重排、混排等等
然后是推特的精排模型
也就是这个Heavy Ranker
这块会包括模型的结构
特征工程 多目标建模
多目标融合等等
第三部分
是推特的图模型预训练表征
也就是这个TwHIN embeddings
主要是基于社交异构图
对用户推文做预训练
大概整体上计划是分这三个部分
那今天先跟大家梳理一下
推特推荐系统的整体架构
那在介绍架构之前呢
要先说一下在推特的场景下
推荐系统的问题定义是什么
首先是输入即Twitter network
这部分是由推文
用户交互行为
等等构成的一个超大规模的异构图
其次呢是输出
就是要预测你和推文
或者其他用户交互的概率
从而进行推文或者用户的推荐
整体问题和常见的
推荐系统其实差距不大
特色地方在于
推特比较关注于social graph的挖掘
也就是社交图的挖掘
那其中就会包括图特征、图预训练
图召回模型等等
推特的推荐系统的整体架构
会包括数据、特征工程和推荐系统服务
其中数据部分呢涵盖了社交图
用户的交互行为
用户画像数据等等
那数据这块应该说是推特的核心资产
也是我们刚才提到过的
由用户推文和互动
交互构成的超大规模异构社交图
其次是特征工程
那推特主要关注社交图的预训练
聚类、社区发现等等
这也是推特的这个特色所在吧
那图预训练得到的向量呢
可以用在向量召回
精排特征等等这些方面
此外还包括了一小部分安全相关的工作
那第三部分
是推荐系统的核心服务Home Mixer
这是一个Twitter定制的Scala框架
可以认为是一个算法工程
那国内的大厂
可能会用像Java、go、C++这些来实现
这个服务由三大部分来构成
第一个是召回就是Candidate Sources
从不同的推荐源获取最好的推文
类似于推荐系统的召回阶段吧
核心的召回方式是图召回
第二个是粗排和精排
使用的是机器学习模型
对推文进行打分排序
推特分为Light Ranker和Heavy Ranker
分别类比推荐系统的粗排和精排阶段
第三个是重排和混排
主要是运用一些启发式的规则
例如过滤自己屏蔽掉的用户的推文
NSFW内容和已经看到的一些推文
保证这个作者的多样性
以及负责广告、推文和作者混排等等
那下面我们会重点来介绍这三个部分
首先是召回
推特有很多的召回数据源
为用户去召回最新的
最感兴趣的相关推文
其中的输入是推文候选池的大小
大概是亿万级别吧
输出的是两类召回通道
分别是你关注的用户圈
叫in-network
和你未关注的用户圈out-of-network
整体上两者的比例大概是五五开
即召回一半你关注用户的推文
还有一半你没有关注的用户的推文
当然
不同用户召回的配比可能会不一样
其中in network召回是主召回路
也就是最大的候选推文来源
目标是从你关注的作者推文中
检索出最新你可能最感兴趣的推文
给到你能够贡献大概50%的推文来源
至少50%吧
那这块推特是使用了自己研发的搜索引擎
Earlybird来检索你关注的人的推文
实际上它就是一个倒排索引
只不过索引里边检索到的推文
要再经过一个Light ranker
海选粗排的模型
进行该召回路的截断
这个我们会在一会讲粗排的时候再去介绍
那out of network召回
是在用户关注的圈子之外
再去寻找相关的推文推荐给用户
这块推特是采取了两种召回的方法
一种是UserTweetEntityGraph
简称UTEG
其实就是协通过滤
通过分析你关注的人
或者有相似兴趣的人的行为
来预测你感兴趣的相关推文
比如2跳的关系U2U2I
那为了实现高效动态图的构建和游走
推特内部自研了GraphJet的图引擎
这个是发表在了VLDB 2016上
GraphJet能够高效的
动态的去维护一个实时的交互图
这个图的节点是用户和推文
它的边是实时的交互行为
并且可以实现高效的地图游走
整个方法大概能够涵盖到15%的推文来源
这个方法得到的召回结果
也要通过一个Light Ranker进行海选粗排
第二种方法
是Embedding Spaces，即嵌入表征学习
他会构建一个更加通用的问题
就是你对哪些推文
以及哪些作者感兴趣
表征学习的目标是训练
得到一个用户表征向量
和推文表征向量
再通过计算user-user、user-tweet
这个表征之间的相似性
来预测用户的兴趣
主要是会分为稀疏嵌入和稠密嵌入两种
那前者稀疏嵌入
就是通过聚类来做表征
后者这个稠密嵌入
就是基于图的学习来做预训练
其中稀疏嵌入最有用的表征模型
是这个SimClusters
这个是发表在KDD 2020上
是一个基于社区发现的异构表征模型
利用矩阵分解算法
基于social graph中比较有影响力的用户
来进行社区发现
并且根据流行度和用户的行为
将推文和用户划分到不同的空间中
那（推特）一共有14.5万个社区
每三周会更新一次
社区有的很大有的又很小
一个用户也可以属于多个社区
每个推文也可以用社区来做嵌入
用推文在这个社区的流行度做表征值
这样就能够计算用户和推文的相似性
并用来进行召回
而稠密嵌入呢
则使用了TwHIN来做user、twitter的
稠密嵌入表征
通过异构图能够得到稠密表征的计算相似度
这样就可以用于图的召回
这个部分的源码
开源在了the-algorithm-ml这个仓库中
我们后续会专门再进行介绍
那除此之外 还提到了这个CR-Mixer
这是一个协调层
是主要是代理执行Out-of-Network的多录召回
并且调用底层的计算服务
包括源信号的抽取
召回结果生成
过滤和粗排
那这个服务主要是在多路召回以后
在精排之前
用来调用多种的召回服务
多路合并和粗排
那么除了推文的推荐以外呢
还有推人的服务
也就是following-recommendation-service
简称FRS
这个是用来推荐作者的
也是一个小的推荐系统
流程基本上跟主的推荐系统是一样的
也包括了召回 排序
过滤 推荐理由啊
排序主要是预测这个关注的概率
以及关注后进到作者主页
去正向交互的概率
二者再进行加权融合
以上就是推特召回的几个核心组件
接下来我们讲一讲这个粗排
它本质上就是一个引擎侧召回通道的海选粗排
包括了两个模型
一个是Early Bird的in-network召回后的
海选粗排模型
一个是这个UTEG的召回
也就是GraphJet在图游走之后的海选粗排模型
两者差异不大
只是特征不太一样
那推特的海选粗排
是一个很老的LR的模型
逻辑回归的模型
主要是用来预测
用户会和推特交互的概率
这个模型（推特）他们内部正准备重构
LR的特征涵盖了用户侧的特征啊
这块就包括基于pagerank算法来
预估声誉的tweepcred模型等等
还有这个推文的特征
包括静态的文本质量
实时转发回复关注等等
以及上下文的特征
这块就包括用户语言等等
那对交互的正样本会进行加权的损失训练
比如说点击的权重为1
点赞的权重为2等等吧
in-network召回的粗排模型中
会用到了这个RealGraph
这个是出自于推特在KDD 2014自研的一个工作吧
本质上是一个LR的逻辑回归模型
但是他预测的是用户和用户的交互概率
其中的输入就是这个RealGraph
这是一个有效的带权重的同构graph
同构图
节点是推特的用户
边是用户与用户的交互关系
这个是由历史行为来构成的
那输出是一个预测用户和用户交互的概率
本质上呢是一个链接预测的任务
那这个模型会基于RealGraph以及边的特征
使用逻辑回归模型来训练
并且预测交互的概率
基于预测得到的交互概率
这个交互概率越高的用户
他的推文就会更多的推荐给你
目前来看
推特并没有专门去构建一个多路召回的
然后把他们合并后的一个粗排模型
估计在推特的这个架构中啊
核心召回路in-network out-network
经过这个海选粗排模型之后呢
会各自挑选750个结果
一共1,500个结果进入到精排
精排使用的是这个parallel masknet
这个模型是出自于新浪微博发表在
DLP-KDD 2021上的论文
这个模型也是新浪微博在
FiBiNet、GateNet、MaskNet、ContextNet
等一系列精排模型中
表现比较好的一个
精排打分的候选级数量是1,500个
是一个多目标的模型
用48M参数的神经网络来实现的
说实话现在可能就有点小了
这个网络在推特交互数据训练
优化点赞转发和回复等目标上
考虑了数千个特征
并且输出了10个level
为每条推特去打分
代表交互的一个概率
根据这些分数
再对推文进行融合排序
一共有10个目标
包括用户喜欢、回复、转发推文的概率等等吧
找时间我们可以再详细解读一下
推特的精排模型以及相关的源码
预测的时候仅仅使用了一个简单的
加权求和的融合排序
看起来权重也应该都是手写的
那到这里呢
推特ranking的核心组件
我们也差不多讲完了
再来说一下这个重排和混排
重排的主要目的呢是做过滤
以及支持一些产品的Feature
嗯属于一个启发式的规则导向
那过滤的内容包括这个可见性
比如去屏蔽的推文是吧
屏蔽的作者
以及（通过重排来保证）这个作者的多样性
内容的平衡性
就是这个控制in-network推文
和out-of-network推文的比例
然后就是基于反馈的疲劳内容
就是当用户有一些负反馈的时候
要需要做一些干预的策略
还包括这个二跳的人脉过滤
主要是排除跟这个推文没有什么二级关联的
out of network的推文
这样就不会推荐
跳数过多的一些无用的用户
专业的术语叫做这个social proof
然后还包括推文以及回复的上下文展示
以及更新检测
这个更新检测
就是用来确定当前设备上的推文
是不是已经过时了
并且发送指令把它替换成为编辑后的版本
那混排主要是负责主页上的混排
也叫这个Homepage Mixer
包括推文、广告、关注的作者
Onboarding prompts等等
这个我们就不过多去介绍了
大家有兴趣可以自己去看一下
那上面介绍这些流程
每天会运行大约50亿次
平均完成时间不到1.5秒
单个管道执行需要220秒的CPU时间
几乎是在应用程序上看到的延迟的150倍
那除了以上我们介绍的这些核心组件以外呢
推特的推荐架构
还包括一些基础设施服务
包括模型的serving服务称为Navi
是一个用Rust语言编写的高性能的
机器学习模型的serving服务
然后就是这个Feeds信息流推荐框架
叫做这个product-mixer
它是一个用来构建内容feed的软件框架
最后就是这个机器学习训练框架
叫twml，Twitter machine Learning
基于的是TF-1
是一个即将被废弃的机器学习框架
目前呢主要是用来训练粗排的
Earlybird light ranker
那以上就是大概完整的
推特推荐算法的架构了
不得不说
这个开源核心算法是一个
的确是一个很大胆的一个举措
在这个马斯克对于推特2.0的愿景中
他也写道
目标是尽可能去提高透明度
算法透明度
同时去掉一些可能
会被不法分子利用的代码
还去掉了一些广告推荐的算法
并且出于安全的考虑
没有发布与Twitter算法相关的训练数据
或者是模型权重
从技术角度来看呢
推特开源代码提供了一个
典型的大型推荐系统的案例
不管是从个人还是公司的角度
都能从中应该学到不少东西
那从推特开源的角度来看呢
他们应该也挺期待开源社区会如何去
看待和分析这个推特的核心代码
以及能够提供哪些比较有意思的建议和思路的
从而给推特的推荐系统
带来一些变化和革新
不管结果怎么样呢
我觉得都是一个共赢的举措
好了今天分享内容呢就到这里
因为个人能力也有限
如果有不足或者是错误的地方还请大家指出
有兴趣的小伙伴们
也欢迎点赞和留言
这样我也有动力把后面的两期节目给做出来
感谢大家的观看我们下期再见
