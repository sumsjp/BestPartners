大家好，这里是最佳拍档，我是大飞
最近的开源社区是事情不断啊
几个开源模型的风头刚过去
老牌开源社区Github又上了热门
只不过，这次并不是什么正面的消息
这两天
开源安全软件公司 Truffle Security 公司的安全研究员乔·莱昂 Joe Leon
他的最新发现震惊了整个开源圈
那就是你亲自在 GitHub 代码仓库中删掉的数据
可能只是个表面功夫，而实际上
你以为删除的数据还是可以被人访问的
更夸张的是
研究人员通过 GitHub 的官方回复得知
后者对这件事情是知情的
并且还是有意设计成这样的
要知道，在去年年初
GitHub 的用户量突破了1亿
而代码库的数量早在 2022 年的时候
就已经达到了 1.9 亿
也由此成为世界上最大的代码托管网站
如今这项调查研究发现
Github上的「删除」似乎形同虚设
这也使得不少网友开始怀疑
点击了这个删除键，究竟有什么用？
如果密码也保存在这些数据中
那是否任何人都可以随意查看呢？
今天我们就来聊聊这件事情
在使用 GitHub 的时候
想必不少人都有过这样的操作
第一步，你看到了一个不错的项目
然后 Fork 了这个公共的仓库；
第二步
你将代码提交到你 Fork 下来的仓库中；
第三步，你删除了这个Fork 的仓库
想象一下，删除之后
你提交到 Fork 仓库的代码还能访问吗？
按理来说，应该不能，对吧？
毕竟你在上面第三步的时候
已经做了删除处理
然而，现实却是
你不仅可以永久访问这个仓库
而且它还不受你的控制
对此，研究人员分享了一段视频
从中可以看到他们 fork 了一个仓库
向其中提交数据
然后又删除了 Fork 仓库
结果仍然可以通过原始的仓库
来访问“已经删除”的提交数据
过去
你可能会认为只要提交了哈希值
就会受到保护
但是如今事实证明并非如此
删除公共仓库的分支以后
相关代码仍然可以通过提交的哈希值来访问
而且，这种情况应该说非常常见
研究人员也调查了一家大型 AI 公司的 3 个经常被 fork 的公共代码仓库
从中轻松地找到了40 个
来自于被删除 fork 仓库中的有效 API 密钥
这个时候有人可能要说了
既然fork 后的仓库能被访问
那我干脆删掉整个公共代码库
这下你总算没法访问了吧？
不好意思，还是可以
GitHub 其实是将代码仓库和 fork 仓库
存储在了一个仓库网络中
并且将原始的“上游”仓库作为根节点
当一个已经被 fork 的上游公共仓库被“删除”的时候
GitHub 会将根节点角色
重新分配给下游 fork 仓库的其中之一
但是，所有来自于“上游”仓库的提交
仍然是存在的
并且可以通过任何下游的 fork 仓库进行访问
在下面的视频中
研究人员创建了一个 repo
对它进行了fork
然后展示了在原始仓库被删除后
仍然可以通过 fork 仓库
来访问没有同步过的原始仓库的数据
在上周，就发生了这样一件事情
研究员莱昂Leon向一家大型科技公司
提交了一个 P1 级别的漏洞报告
显示他们意外地提交了一名员工的 GitHub 账户私钥
这个账户拥有对公司整个 GitHub 组织的访问权限
随后公司立即删除了这个仓库
但是由于它已经被fork过了
所以研究员仍然可以通过 fork的仓库
来访问包含敏感数据的 commit
即使这个 fork 仓库从来没有与原始的“上游”仓库同步过
讲到这里
一些朋友可能已经意识到了问题的严重性
那就是数据能否被再次访问
并不取决你代码仓库的性质
而是是否被fork过，换句话说
只要有至少一个 fork 仓库
你提交到公共存储库的任何代码
就可能会永远的可被访问
那有个问题我们就要想了
私有仓库中的数据也可以被访问么？
我们先回忆一下在Github上创建一个开源项目仓库的过程
首先我们可能会创建一个私有仓库
然后再fork这个仓库的一个私有版本
提交一些不打算公开的代码，最后
我们将之前的上游仓库设为公开
并且保持fork仓库仍然是私有的
那么
你私有仓库中的代码是否可以被公众所查看呢？
不幸的是，答案是肯定的
在上游仓库公开之前
你在fork仓库提交的任何代码
当上游仓库被公开后
都是可以被访问的
但是当你将“上游”仓库公开以后
你之后再对私有 fork 仓库库所做的任何提交
都是不可以查看的
这是因为更改“上游”存储库的可见性之后
导致产生了两个仓库网络
分别是一个用于私有版本
一个用于公共版本
不过，就算私有版本无法访问
公共版本还是可以被查看的
这就对使用GitHub的企业和个人用户
构成了严重的安全隐患
他们的机密数据可能会无意中
被暴露在组织的公共 GitHub 仓库中
Truffle Security 引入了一个新的安全术语
CFOR（Cross Fork Object Reference）
来描述这个安全漏洞
指的是当一个仓库 fork 可以访问另一个 fork 中的敏感数据
包括来自于私有和已经被删除的 fork 的数据
就会出现 CFOR 漏洞
与不安全的直接对象引用类似
在 CFOR 中
用户只需要提供commit的哈希值
就可以直接访问提交的数据
虽然无论你删除了哪种仓库
GitHub 的仓库网络都会从标准的GitHub UI
以及正常的 git 操作中
删除对 commit 数据的引用
但是删除之后
这些数据仍然是存在的
并且是可以被访问的
你只需要知道 commit 的哈希值
就可以直接访问不属于自己的数据
如果用户知道了某个 commit的SHA-1哈希值
那么就可以直接通过这个地址来访问
https://github
com/<user/org><repo>commit/<commit_hash>
而进入这个commit之后
我们会看到一条黄色的横幅
显示 “这个 commit 不属于该仓库的任何分支
可能属于仓库之外的 fork”。
而commit的 哈希值其实可以通过 GitHub 的 UI 进行暴力破解的
因为git 协议允许在引用 commit 的时候
使用短 SHA-1 值
短 SHA-1 值是避免与其他 commit 哈希值发生冲突碰撞
所需要的最少的字符数
最小值为4
因此，所有4个字符的 SHA-1 值
数量为16的4次方
65,536
也就是说
这些字符只有 65536 种可能的组合
对于现代计算机来说
这个数字范围已经非常小了
所以暴力破解所有可能的值是比较容易的
大家可以看一下屏幕上的例子
在 TruffleHog 仓库中的这个commit
如果想要访问这个 commit
用户通常会访问包含完整 SHA-1 哈希值的 URL
也就是这个链接地址
https://github
com/trufflesecurity/trufflehog/commit/07f01e8337c1073d2c45bb12d688170fcd44c637
但是实际上
用户其实并不需要知道完整的 32 个字符的 SHA-1 哈希值
只需要知道前四个字符就可以了
GitHub 基本就能自动补全标识符的剩余部分
所以他们只需要正确猜出短 SHA-1 值即可
这里也就是 07f01e
于是，只要破解掉了哈希值
上游仓库就如同没有门的公共厕所一样
你可以想来就来
想走就走，把每个人的隐私看个精光
如此一来
这显然是个有风险的安全漏洞
但是 GitHub 却将 CFOR 视为一种合法机制
认为并不是什么大问题
这又是怎么回事呢
事实上
Github将这个问题看作是一项 feature
而非 bug
在知悉这个漏洞被披露之后
GitHub 方面的回应是
这是一项有意为之的设计
而且根据官方文档中的描述
它的效果也完全符合预期
很明显
这个问题多年来一直为Github内部所知
早在 2018 年
就曾经有人向 GitHub 通报过这个漏洞
也同样收到了类似的回复
Truffle Security 公司的联合创始人兼 CEO 迪伦·艾瑞Dylan Ayrey 解释道
这个问题属于所谓的“悬空提交”dangling commit
悬空提交是 git 中的概念
并不属于 GitHub 的功能
因此
悬空提交可以存在于任何 git 平台当中
包括Gitbucket、GitLab、GitHub 等等
具体来讲
悬空提交在任何给定的代码仓库当中都会存在
因为项目的历史记录会以树状结构存在
所有旧版本的代码都彼此连接在一起
git 提交的时候
会捕捉代码仓库在特定时间点上的状态快照
包括对于代码和数据的变更
每次提交都会由加密哈希提供唯一的标识
比方说
虽然删除分支会删除指向特定提交链的引用
但是提交本身并不会从仓库的对象数据库中删除
所以说
悬空提交本身就是 git 基础文档的组成部分
但是
每个 git 平台对于悬空提交的处理方式
是由平台本身决定的
而非受制于git 的规范
艾瑞Ayrey 还提到
即使与代码树之间的连接被切断
像Bitbucket、GitLab 和 GitHub 这些平台
也仍然会保留这些提交
所以
只要掌握能够直接访问这些内容的标识符
就仍然可以正常下载相关的数据
艾瑞Ayrey 表示
虽然这个问题早已被公之于众
但是在 GitHub 中
还存在一个与fork相关的类似问题
因为fork并不属于 git 规范的一部分
所以每家平台会采取不同的实现方式
对于GitHub来说
只要用户掌握了标识哈希或者是其中的某一部分
就可通过fork仓库来下载悬空提交
这样的话
如果一家公司不小心上传了什么机密的内容
比如机器学习的数据集或者账户密钥
GitHub就会老老实实把所有机密全部快照下来
从而构成机密泄露的隐患
在艾瑞Ayrey看来
Github的声明只是一种自欺欺人的行为
因为Github完全可以不在fork之间
共享这样的fork池
从而确保推送到某个fork的提交
是不可以通过另一个fork下载的
或者也可以设计一些新的功能
比如说允许用户永久的删除提交
而非让它处于悬空的状态
但是，Github到现在什么都没有做
甚至懒得把这件事当作一个漏洞来处理
Truffle Security 认为
GitHub 应该重新考虑自己在这件事情上的立场
毕竟普通用户还是希望在数据安全方面
能够明确的区分公共和私有仓库
包括删除操作应该真的将提交数据给删除掉
可惜
短时间内指望Github修复这个问题是不可能了
Truffle Security表示
如果你真的在Github上上传过敏感的东西
比如说密钥
那么最后只剩下一个解决办法
那就是更换密钥
仅仅删除相关的仓库或者引用是不够的
你必须立即更换密钥
并且检查它是否被人不当地使用过
好了
以上就是这次GitHub事件的来龙去脉了
如果按照Github的说法
那么这么多年来这个所谓的Feature
应该已经泄露了不少意外提交的敏感信息了
那么大家是如何看待CFOR漏洞的呢？
你认为它应该被修复吗？
欢迎在评论区留言
感谢大家的观看，我们下期再见
