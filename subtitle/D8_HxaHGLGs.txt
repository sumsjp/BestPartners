大家好，这里是最佳拍档，我是大飞
相信AI行业的朋友都会有一个感觉
那就是Agent正在从概念走向落地
只不过让它从“能跑起来”，
到“能稳定用起来”，
中间还隔着一道巨大的鸿沟
而今天我想和大家聊的“12-Factor Agents”，
翻译过来就是Agent的十二个设计原则
就是为了填平这道鸿沟而生的
正好前几天也有观众在评论区提到了它
需要说明的是
这套原则不是一个像LangChain这样
可以直接拿来用的“工具箱”，
而是一套“方法论”，
就像多年前软件开发领域的“12-Factor App”原则一样
它把传统软件工程里经过验证的最佳实践
创造性地用到了大模型驱动的Agent开发里
它的核心目标也很明确
那就是弥补Agent从原型开发到生产级应用的鸿沟
让Agent在可靠性、可伸缩性、可维护性、可调试性和安全性上
达到企业级应用的标准
在详细介绍这十二个原则之前
我们还要稍微花点时间
介绍一些跟这个项目有关的背景
12-Factor Agents项目的发起者
是一家叫HumanLayer的旧金山创业公司
创始人是德克斯特·霍西（Dexter Horthy）
他的经历很有意思
17岁就开始在NASA喷气推进实验室编程
后来在开发工具公司Replicated待了7年
从工程师做到产品经理再到高管
帮Hashicorp、DataStax这些知名企业
交付过本地K8s产品
这段经历让他对“生产级系统”的严谨性有着极深的理解
因为分布式系统的可靠性
以及容器编排的可扩展性
这些都是他多年来每天要面对的问题
真正让他转向Agent领域的
是2023年的一个项目
当时他正在构建一个基于Slack的Agent
想用来管理SQL数据库
在开发过程中
他发现了一个被很多人忽视的关键问题
那就是Agent在执行任务的时候
怎么才能有效地把人类“拉进来”呢？
比如
当Agent需要执行一条可能影响生产数据的SQL语句时
它不能自己做主，得让人类审核同意
但是传统的Agent设计
都是让人类坐在屏幕前等AI说话
AI不会主动找人类要反馈
这个“Human-in-the-Loop（人类在环）”的痛点
不仅让他成立了HumanLayer
更是直接催生了12-Factor Agents的核心理念
而霍西的愿景
就是要推动Agent从人机问答聊天的“第一代”，
以及由框架驱动的“第二代”，
进化到“第三代”自主Agent
能自己做的事情自己做
做不了的事及时找人类帮忙
既高效又安全
讲完背景
我们来看看12-Factor Agents这个项目本身
目前它在GitHub上有13.8k星标、978个fork
它的代码主要用TypeScript写的
还有少量的Python
整个项目最核心的创新
是它提出的“反框架”理念
和传统框架不一样
它不提供“黑盒式”的解决方案
而是坚持让开发者“完全控制核心组件”。
为什么要这么设计？
因为在企业级应用里
透明度、可调试性、可维护性
比“开发快”更加重要
比如一个金融领域的Agent
开发者必须知道每一步的逻辑是什么、数据流向哪里
不能把核心逻辑都交给框架的黑盒
接下来
我们就来逐个拆解它的12个设计原则
这是项目的核心
每个原则都对应着生产级Agent的一个关键需求
我会尽量讲清楚它是什么
为什么重要以及怎么落地
原则1：
自然语言到工具调用（Natural Language to Tool Calls）
这个原则的核心是，Agent的核心能力
应该是把人类的自然语言指令
准确转换成结构化的工具调用
不是让Agent直接“回答问题”，
而是让它在理解问题后
能够调用合适的工具去解决问题
比如，用户说
帮我查一下上个月的销售总额
然后生成一个Excel报表
Agent不能直接输出数字
而是要先把这句话转换成两个结构化的工具调用
第一个调用“销售数据查询工具”，
参数是“时间范围：上个月”；
第二个调用“Excel生成工具”，
参数是“数据来源：
销售数据查询结果”。
为什么这很重要？
因为自然语言是模糊的
但是工具调用是精确的
结构化的工具调用能够让Agent的行为变得“可预测”，
也方便开发者调试
比如如果Agent没生成报表
开发者可以查一下“是不是工具调用的参数错了”，
而不是去猜“是不是Agent没有理解自然语言”。
落地这个原则的关键
是设计清晰的工具接口
每个工具的功能是什么、需要哪些参数、返回什么结果
都要定义得清清楚楚
比如“销售数据查询工具”，
要明确参数包括哪些必填项和可选项
返回结果又包括哪些字段
这样大语言模型才能准确的调用
原则2：
拥有你的提示词（Own your prompts）
提示词是大模型应用的“灵魂”，
但是很多框架会把提示词藏在内部
比如LangChain
你调用的时候看不到它给模型发了什么提示词
所以这个原则就是要强调
开发者必须能完全控制提示词的设计、修改和版本管理
为什么要“拥有提示词”呢？
因为不同业务场景需要不同的提示词
比如同样是客服Agent
卖电子产品的和卖服装的
提示词的语气、需要包含的产品知识都不一样
如果提示词藏在框架里
开发者没法根据业务需求来调整
Agent的效果就会打折扣
另外，生产环境里
提示词的版本管理也很重要
比如你修改了提示词后
Agent的准确率下降了
这时候需要能回滚到之前的版本
如果提示词在框架里
你根本没法做版本控制
落地这个原则
建议大家把提示词当成“代码”一样管理
把它存在代码仓库里
做版本控制，还可以做A/B测试
比如同时用两个版本的提示词
看哪个让Agent的工具调用准确率更高
再选择效果好的那个
原则3：
拥有你的上下文窗口（Own your context window）
大模型的上下文窗口长度是有限的
怎么管理上下文
会直接影响到Agent的性能
这个原则的核心是
框架不能替你来决定
哪些内容要留在上下文里
哪些要删掉
开发者要自己控制上下文窗口的管理逻辑
比如，一个处理长对话的Agent
用户聊了半小时
上下文窗口快满了，这时候该删什么？
是删最早的对话，还是删重复的信息
还是删不重要的细节呢？
不同场景的答案是不一样的
如果是客服对话
可能需要保留用户的核心诉求
比如“要退款”，删掉其他无关的闲聊；
如果是技术支持对话
可能需要保留之前提到的报错信息
删掉无关的产品介绍
如果框架替你做了决策
比如默认删最早的对话
就可能会导致Agent忘记用户的核心诉求
进而做出错误的判断
所以开发者必须自己来设计上下文的管理逻辑
比如基于“信息的重要性”排序
优先保留关键的信息
删掉次要的信息
落地这个原则
需要开发者定义一个信息重要性的评分标准
比如用户的需求、系统的关键参数、工具调用的结果
这些是高重要性的，要保留；
用户的礼貌用语、重复的提问
这些是低重要性
可以删除
原则4：
工具只是结构化输出（Tools are just structured outputs）
这个原则有点反直觉
它把“工具调用”理解成模型的一种结构化输出
而不是“Agent去调用一个外部工具”。
比如
模型输出的不是“我要调用销售数据查询工具”，
而是一个JSON格式的结构化数据
为什么要这么理解？
因为这能简化系统的架构
Agent不需要“知道怎么调用工具”，
只需要“输出结构化的工具调用指令”，
然后由专门的“工具执行模块”去解析这个指令
调用对应的工具
这样一来
Agent的逻辑和工具执行的逻辑就分开了
更加容易维护
比如
如果“销售数据查询工具”的接口变了
开发者只需要修改“工具执行模块”的代码
不用去改Agent的逻辑
如果要新增一个工具
也只需要在“工具执行模块”里增加一个新的工具实现
Agent只需要输出对应的结构化指令就行
落地这个原则
关键是统一工具的调用格式
比如所有的工具调用都用JSON格式
包含工具名和参数两个字段
这样“工具执行模块”就能用统一的逻辑来解析
原则5：
统一执行状态和业务状态（Unify execution state and business state）
在传统的Agent设计里，执行状态
比如“正在调用工具”或者“等待用户反馈”，
和业务状态
比如“用户的订单号”或者“销售数据查询结果”，
这两块基本都是分开管理的
执行状态存在Agent的内存里
业务状态存在数据库里
这样很容易出现“状态不一致”的问题
比如Agent以为自己已经调用了工具
但是实际上工具调用失败了
业务状态没更新
导致Agent后续的行为出错
这个原则的核心是
把执行状态和业务状态放在一起来管理
形成一个统一的“全局状态”。
比如
全局状态里既包含当前步骤等待工具返回结果这样的执行状态
也包含工具调用参数为时间范围等于上个月的业务状态
还有工具返回结果为销售额100万这样的业务状态
这样做的好处是，一旦Agent出错
比如说进程崩溃了
重启后就可以从全局状态里恢复
因为它知道自己之前执行到哪一步了
有哪些参数和结果
所以不用重新开始
比如Agent在调用工具后崩溃了
重启后通过查看全局状态
发现已经调用了工具
但是还没处理结果
就可以直接去拿工具的返回结果
继续执行后续步骤
而落地这个原则
建议用一个专门的状态存储服务
比如Redis或者其他数据库来管理全局状态
每个Agent任务都有一个唯一的ID
通过ID来查询对应的全局状态
原则6：
使用简单的API来完成启动、暂停和恢复（Launch/Pause/Resume with simple APIs）
在生产环境里
Agent可能需要一些处理长时间运行的任务
比如生成一份年度销售报告
可能就需要调用多个工具、处理大量的数据
耗时几个小时
这时候，如果需要暂停任务
或者任务失败后要进行恢复
就需要简单的API来操作
这个原则的核心是
Agent的启动、暂停、恢复
都应该通过简单的API来实现
而不是通过修改代码或者配置
比如
调用“POST /agent/start”来启动任务
调用“POST /agent/pause?
task_id=xxx”来暂停任务
为什么需要简单API？
因为在生产环境里
这些操作可能会由运维人员通过自动化工具来执行
而不是开发者手动操作的
比如系统维护的时候
运维工具可以批量调用“暂停API”，
暂停所有正在运行的Agent任务；
等维护结束后，再批量调用“恢复API”，
让任务继续执行
落地这个原则
需要设计符合RESTful风格的API
明确每个API的参数、返回值、错误处理逻辑
比如对于“暂停API”来说
如果任务已经暂停
那么可以返回“400 Bad Request”，
并且提示“任务已经处于暂停状态”。
原则7：
通过工具调用来联系人类（Contact humans with tool calls）
这是12个原则里最有创新性的一个
它的核心是
让Agent通过“调用人类工具”的方式
主动联系人类获取反馈
而不是等人类主动找它
这里的“人类工具”，
可以理解成一个专门用来和人类交互的工具
比如“发送审批通知工具”“获取人类反馈工具”。
比如
Agent要执行一条修改生产数据库的SQL语句
它会先调用“发送审批通知工具”，
参数是“审批内容：执行SQL语句xxx
审批人：数据库管理员”；
数据库管理员通过审批之后
Agent会调用“获取人类反馈工具”，
拿到“审批通过”的结果
再执行SQL语句
传统的人机交互是“从人类到AI”，
而这个原则把它变成了“从AI到人类”，
让Agent主动发起交互
人类来被动响应
这种方式特别适合生产环境
因为人类不用时刻盯着Agent
Agent只有在需要的时候才会去找人类
既高效又安全
落地这个原则
需要设计专门的“人类交互工具”，
比如集成企业微信、Slack、邮件等通知渠道
让Agent可以通过这些渠道联系到人类；
同时设计一些反馈收集机制
比如人类点击通知里的“同意或拒绝”按钮后
反馈结果
能够自动回到agent的全局状态里
原则八拥有你的控制流
控制流呢就是agent的执行逻辑
比如说先调用工具a
再根据工具a的结果
决定调用工具b还是工具c
这个原则的核心是
开发者必须完全控制控制流
不能让框架替你来决定执行的逻辑
很多框架会提供一些预定义的控制流
比如“顺序执行链”或者“条件分支链”，
但是企业级应用的控制流往往很复杂
比如一个供应链Agent
需要先调用“库存查询工具”，
如果库存充足，再调用“发货工具”；
如果库存不足，则调用“采购工具”，
采购完成后再调用“发货工具”，
中间还要考虑采购失败的情况
这时候可能还需要调用“通知采购经理工具”。
如果采用框架的预定义控制流
很难覆盖这么复杂的逻辑
就算能覆盖，后续修改起来也很麻烦
所以开发者必须自己来设计控制流
比如用代码写清楚“每一步该做什么
遇到什么情况该怎么处理”。
落地这个原则
建议采用“状态机”的思想来设计控制流
每个状态对应Agent的一个执行步骤
状态之间的转换由“条件”触发
比如“库存查询完成”状态
转换条件包括“从库存充足到发货状态”，
或者从“库存不足到采购状态”，
以及从“查询失败到重试状态”。
原则9：
将错误压缩到上下文窗口（Compact Errors into Context Window）
Agent在生产环境里一定会出错
比如工具调用失败、模型返回错误信息、参数格式不对等等
这个原则的核心是
把错误信息以紧凑的形式
放进模型的上下文窗口里
让模型能根据错误信息来调整行为
比如
Agent调用“销售数据查询工具”的时候
如果因为参数“时间范围”的格式写错了
工具就会返回错误
提示参数的时间范围必须符合日期的格式
这时候
Agent要把这个错误信息压缩后
放进上下文窗口中
再让模型重新生成工具调用
而模型看到错误信息后
就会把错误的日期格式
改成正确的日期格式
为什么要“压缩”错误信息呢？
因为上下文窗口的长度是有限的
如果错误信息太长
比如几百行的堆栈信息
就会占用大量的窗口空间
导致其他的重要信息被删掉
所以需要把错误信息提炼成“关键信息”，
比如包括错误类型、错误原因、解决方案的提示等等
落地这个原则
需要设计错误信息的压缩逻辑
比如提取错误类型、错误来源、错误原因、修复建议
再去掉无关的堆栈信息、日志ID等等
原则10：小而专注的Agent（Small
Focused Agents）
这个原则借鉴了微服务的思想
不要做一个“无所不能”的超级Agent
而是做多个“小而专注”的Agent
每个Agent只负责一个特定的任务域
比如，不要做一个“企业管理Agent”，
而是拆成“销售数据Agent”，
负责查询、分析销售数据、“库存管理Agent”，
负责查询库存、触发采购
“客服Agent”，负责处理客户咨询
每个Agent只关注自己的任务域
这样逻辑更加简单
维护也更加方便
为什么要“小而专注”呢？
因为超级Agent的逻辑太复杂
容易出错
也难以调试
比如一个超级Agent
既能处理销售数据
又能处理库存，还能处理客服
一旦出了问题
开发者要在几百行代码里找原因；
而小的Agent出了问题
只需要看对应任务域的代码
效率会高很多
另外，小的Agent还方便团队分工
你可以让销售团队来负责维护“销售数据Agent”，
库存团队来负责维护“库存管理Agent”，
不用所有的人都盯着一个超级Agent
落地这个原则
关键是要做到“任务域的拆分”，
根据业务模块、职责范围来拆分Agent
每个Agent的输入、输出、工具调用都要明确
避免功能重叠
比如“销售数据Agent”的输出是“销售报表”，
“库存管理Agent”的输入是“销售报表”，
两者通过结构化的数据交互
不用共享内部逻辑
原则11：
从任何地方触发（Trigger from anywhere）
企业里的系统是多种多样的
有像Slack、企业微信这样的沟通工具
也有CRM、ERP这样的业务系统
还有定时任务、webhook这样的自动化工具
这个原则的核心是
Agent应该能从任何这些地方触发
而不是只能从某个固定的界面触发
比如
“销售数据Agent”可以被这几种方式触发
一是运营人员在Slack里发出“查询上月销售数据”的消息；
二是CRM系统里当新的订单超过100万的时候
自动触发Agent生成报表；
三是每周一早上8点
定时任务触发Agent生成周报表
为什么要“从任何地方触发”呢？
因为这样才能让Agent“融入”到企业的现有工作流里
而不是让员工去“适应”Agent
比如运营人员习惯用Slack工作
就不用特意打开Agent的界面
在Slack里就能触发任务
业务系统有事件发生的时候
Agent也能自动响应，不用人工干预
落地这个原则
需要设计所谓的“触发适配器”，
针对不同的触发来源
开发对应的适配器
比如Slack适配器
负责监听Slack的消息
解析出触发指令；
CRM适配器，负责监听CRM的事件
触发Agent；
定时任务适配器
负责按时间来触发Agent
每个适配器的输出
应该都是统一的“触发指令”，
这样Agent不用关心指令来自哪里
原则12：
让你的Agent成为无状态的归约器（Make your agent a stateless reducer）
这个原则借鉴了函数式编程里的“归约器（reducer）”的概念
也就是Agent本身是无状态的
它的行为只由“当前的输入”和“外部的状态”所决定
不依赖内部存储的状态
“归约器”的逻辑是
接收“当前状态”和“输入”，
处理后输出“新的状态”。
比如，Agent接收的“当前状态”，
是已经调用销售数据查询工具
但是没有生成报表
输入是销售数据查询结果为100万
处理后输出的新状态是
已经生成报表，等待发送给运营人员
为什么要做到“无状态”呢？
因为无状态的Agent更容易扩展
比如
当有100个用户同时触发销售数据Agent的时候
服务器可以启动100个Agent实例
每个实例处理一个用户的任务
不用共享状态；
如果某个实例崩溃了
其他实例也不受影响
新的实例可以从外部状态里恢复任务
落地这个原则
关键是把所有状态都放在外部存储里
Agent只负责处理输入
生成新的状态，不自己保存任何状态
比如Agent处理任务的时候
先从外部存储获取当前状态
处理后再把新状态写回外部存储
然后就可以释放资源
下次处理的时候再重新获取状态
这12个原则不是孤立的
而是相互配合的
比如原则12“无状态归约器”，
需要原则5“统一执行状态和业务状态”来支撑
原则11“从任何地方触发”需要原则1“自然语言到工具调用”来保证指令的统一
原则7“通过工具调用联系人类”需要原则10“小而专注的Agent”来降低交互复杂度
它们共同构成了一套完整的生产级Agent设计体系
解决了可靠性、可扩展性、可维护性等核心问题
很多朋友可能会问
有了LangChain、LlamaIndex、AutoGen这些框架
为什么还需要12-Factor Agents呢？
这里需要明确一点的是
它们不是竞争关系
而是一种互补关系
12-Factor Agents是“设计原则”，
框架是“实现工具”，
原则可以用来指导工具的使用
简单来说
12-Factor Agents是球队的“教练”，
告诉队员们“怎么打才能赢”，
而框架是“球员”，
负责执行具体的战术
比如
你可以用LangChain来搭建Agent
但是要遵循12-Factor Agents的原则
自己控制提示词（原则2）、自己管理上下文窗口（原则3）、统一状态管理（原则5）等等
这样搭建出来的Agent才能符合生产级的标准
所以
12-Factor Agents不是要取代任何框架
而是要让框架的价值最大化
很多开发者用框架做原型很顺手
但是一到生产环境就出问题
本质上是因为没遵循工程化的原则
而12-Factor Agents就是要填补这个空白
让框架从“原型工具”变成“生产工具”。
对于从事Agent开发的朋友
12-Factor Agents的启发
不只是技术层面的
更多是思维层面的
首先是“设计思维的转变”，
从“追求快速原型”转向“注重生产质量”。
以前我们可能觉得“先跑起来再说”，
但是现在要意识到
生产环境里，“稳定”比“快”更重要
前期多花时间设计提示词、控制流、状态管理
后期能省很多调试的时间
其次是“架构意识的提升”，
不要只关注模型的调参、提示词的优化
还要关注系统架构
比如状态怎么存储、工具怎么解耦、错误怎么恢复
这些架构层面的问题
才是决定Agent能否落地的关键
第三是“用户体验的创新”，
不要局限于“聊天界面”的交互模式
要思考“Agent怎么能主动融入用户的工作流”。
比如，用户在处理订单的时候
Agent主动提示“这个客户有退款记录
需要注意”；
用户在写报告的时候
Agent主动调用数据工具
提供最新的销售数据
这种“主动协作”的体验
才是Agent的核心价值
第四是“跨学科整合”，
Agent开发不是纯AI的工作
而是需要结合分布式系统、DevOps、产品设计等多个领域的知识
比如
分布式系统的“无状态设计”和“容错机制”，
能够帮助Agent实现高可用
而DevOps中的“CI/CD”和“监控告警”，
能够帮助Agent实现快速迭代和稳定运行
包括产品设计里的“用户旅程”，
也能帮Agent设计更友好的人机交互
最后，我想引用HumanLayer的一句话
那就是不要重复传统软件开发早期的弯路
而是从一开始就建立良好的工程文化和设计原则
Agent是AI落地的重要载体
而12-Factor Agents
就是帮助我们把Agent做“好”、做“稳”的关键一步
希望今天的内容
能够给正在开发Agent的朋友
带来一些启发
感谢大家观看本期视频
我们下期再见
