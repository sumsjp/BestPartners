大家好，这里是最佳拍档，我是大飞
最近从Google跳槽到OpenAI的AI科学家
Hyung Won Chung
比较拗口，我就简称尚哥了
他最近做了一个技术演讲
涵盖了大语言模型的很多最新动向和技术细节
今天大飞在这里跟大家分享一下
可以说
这次分享可以跟安德烈卡帕西的State of GPT演讲齐名
高屋建瓴、深入浅出
就连PaLM-2的联合负责人都曾经评价说
全世界没有多少人，能像尚哥一样
拥有如此丰富的全栈大语言模型的经验
这次演讲的题目定为「2023年的大型语言模型」，
主要是对大语言模型领域的发展做一个总结
为什么要特意强调“2023年”这个时间点呢
因为今天我们所称的大型模型
在未来几年内可能就会被当做小型了
随着我们对“规模”的定义发生变化
我们在目前大语言模型中所做的许多见解和结论
都可能会变得过时，甚至不再适用
尚哥认为，GPT-4即将超越拐点
并且性能将实现显著的跳跃
在他看来，我们所有人需要改变观点
大语言模型确实蕴藏着巨大的潜力
只有参数量达到一定规模时
能力就会浮现
好了
接下来我们就来看看他具体讲了什么
首先，他提出了一个观点
就是参数规模越大
大语言模型就势必发生涌现
在这张图上，X轴是模型的规模
比如模型的参数数量、训练数据的大小、所用的计算资源等
而Y轴是各个任务的某些性能指标
我们已经反复观察到这样的模式
小型模型在某些任务上几乎无法取得任何进展
但是当模型达到一定规模的时候
它突然就能够完成这些任务了
有时甚至能做得很好
我们称这种现象为“涌现”，
就像某种能力突然“涌现”出来
这为AI研究者提供了一种全新的视角来思考
即便当前一代的大语言模型还无法展现出某些能力
我们也不应该轻言「它不行」。
相反
我们应该思考为什么「它还没行」，
这就让推理思路发生根本性的转变
从「一些方法现在不起作用」，
到「一些方法只是在当前不起作用」。
一旦模型规模扩大
许多结论都会发生改变
也就是说，虽然有些最新方法
可能不适用于当前的模型
但是3-5年后，可能变会得起作用了
为什么大家以前不这么觉得呢
因为我们已经习惯
在一个基本规律不会真正改变的环境中去工作
比方说
如果你在物理实验或者热力学研究中有了一个新的想法
但是实验失败了
你知道这个想法在三年、甚至三十年后都不会成功
但是在AI领域，情况则完全不同
例如，GPT-4发布后
研究者们在它的基础上进行了大量实验
有了很多新的想法和直觉
但是随着新模型的发布
之前的想法和直觉就变得过时了
这种转变需要我们不断地更新、抛弃那些基于过时观点的直觉
这对于许多研究者来说是一个新挑战
但也是一个机会
对于一些新入行的研究者来说
他们可以尝试那些在以前的模型上不起作用的想法
而在新的模型上
这些想法可能突然就有效了
他自己平时在实验过程中
也会记录下失败的过程
每当有了新的模型
他就会再次运行实验
再来查验哪些是成功的
哪些是失败的，以此往复
这样一来
就可以不断更新和纠正自我认知和理解
适应技术的日新月异
当然
并不是说所有的任务都需要大规模的处理
但是有时确实需要
以GPT-3和GPT-4为例
这两个模型代表了不同的规模
假设有三种能力，对于“能力一”，
GPT-4尚未达到
但它非常接近一个转折点
这意味着我们可能会突然看到一个跃进式的改进
对于“能力二”，
尽管我们有了强大的GPT-4
但仍然有很大的距离
目前的方法可能还不能提供实质性的帮助
而对于“能力三”，
GPT-3已经超越了转折点
在这个阶段
我所进行的研究可能只会带来渐进式的改变
实际上，我们要解决的问题
并不只有这些
但是只要坚持这种思维框架
经常回顾和反思，更新我们的直觉
就能明白我到底在解决哪种问题
这就是核心思想
总的来说
我们所做的一切都与“规模”有关
而从“规模”的角度看问题非常关键
那么，已经有了规模的发展性观点后
我们该如何扩大参数规模呢？
我们知道，目前为止
所有的大型语言模型都采用了Transformer架构
不过
Transformer的内部结构对我们来说并不那么关键
我们可以从功能的角度来看待Transformer
将它看做是一个包含一系列矩阵乘法的序列到序列的映射
并且可以进行相应数组的转换
它的输入是一个长度为D的序列
代表Transformer的宽度和长度
输出也是一个同样大小的数组
以一个句子为例
Transformer会先进行标记化
Tokenization
通过BPE或者句子分段等方法
得到一个整数列表
再把它嵌入到一个隐藏空间中
就得到所谓的词嵌入Word Embedding
这时
每个token都被表示为一个长度为D的向量
并且我们有这些向量的总长度
这就是实际计算的开始
我们有N个Transformer层
这些层只是从一个序列映射到另一个相同的序列
从这里开始，一切都与规模有关了
我们希望每个序列token都能与其他token进行交互
在Transformer中
其中一种方法就是通过计算它们的点积
这些计算主要在高维数组中进行
涉及到矩阵乘法和数组计算
在Transformer模型计算的最后阶段
我们会得到一个序列
接着
我们采用特定的损失函数来评估模型的预测
这个损失函数基于模型对下一个token的预测
来计算最大可能性，预测下一个token
并且根据预测的准确性得到一个数值
有了这个数值后
我们会进行反向传播
更新模型的所有参数
在实际应用中
这些计算都是批量进行的
会同时处理多个数据点
整个数据批次中唯一的相互依赖
是在最后的计算损失步骤
我们会取平均值
因此，扩大Transformer的规模
就是让很多很多机器高效地进行矩阵乘法
这涉及到如何将Transformer中的所有这些矩阵合理地分配给各种机器
关键是要确保在尽量减少机器之间的通信的同时
进行合理的分配
那真正如何实现呢
通过将注意力机制拆分为单独的头
利用多台机器和芯片
并使用GSPMD方法进行无需任何通信的并行化
然后借助Jax的前端工具PJit将阵列轴映射到硬件
就可以实现大型语言模型的并行化
不过，从机器学习的角度来看
实际预训练的成本依然是非常高的
预训练的核心是所谓的"缩放法则"。
这种缩放定律是基于小规模模型的数据开发的
如果我们可以预测模型的扩展损失
那么将非常有价值
比方说，在Palm的训练过程中
就遇到了损失值的高峰现象
大约出现了20次损失高峰
造成了大量计算资源的浪费
尽管随着技术进步
像Llama这些模型的训练已经变得更加容易
但是我们同时也发现
技术规模的增长速度超过了解决这些问题的速度
大多数人并不会尝试在更大的规模上训练模型
而是选择等待其他研究者的进展
并在其他人的基础上进行进一步的研究
因此
仅仅增大规模并不能解决所有问题
在模型训练完成后
我们还需要进一步优化模型
当前的大语言模型分为四个主要阶段
第一个阶段是预训练阶段
接下来的三个阶段分别是指令微调
或者称为监督微调SFT
然后是奖励模型的训练
以及策略模型的训练
接下来主要讲一下这三个阶段
首先，指令微调阶段的核心思想
是为所有任务建立从自然语言指令到自然语言响应的映射
从BERT到T5，随着模型规模的增长
我们发现模型确实有能力在某种程度上理解指令
并利用自然语言的丰富性来统一各种任务
这就是指令微调的基本思想
进一步地
我们也可以将这种方法扩展到对话场景中
其中模型可以与另一个代理进行交互
而不仅仅是简单地响应指令
这就是指令微调的核心思路
这里面会存在一个问题
就是如果训练集中包含更多的指令
是否能得到一个更好的模型？
经过实验验证
虽然增加更多任务可以提高性能
但是效果是递减的，存在着局限性
关键还是在于任务的多样性
从这个问题出发
我们需要考虑学习的目标是什么
在这个学习阶段
我们到底在教模型什么呢？
在监督学习中
我们常常使用交叉熵损失或者最大似然估计
作为学习目标
这意味着对于给定的输入
我们期望模型能够输出一个唯一正确的答案
而所有其他答案都被认为是错误的
在强化学习中
这种方法被称为“行为克隆”。
简而言之，如果我们有足够多的示例
模型应该能够模仿或“克隆”这些行为
从而在新的、未见过的情境中做出正确的决策
然而，随着任务的复杂性增加
为模型明确定义“正确的行为”变得越来越困难
打个比方，我们用2+3=5
或者翻译一句简单的句子来训练模型
但是模型真正面对的问题
可能是给一个五岁的男孩写一封来自圣诞老人的信
解释圣诞老人并不真实
同时要确保这个信息传递得足够温柔
不伤害这个孩子的感情
对于这样的问题
其实很难确定一个最佳答案
更不用说有一个确定的答案了
所以，当面对这种情况时
就不太能使用最大似然估计了
我们的目标越来越是教导模型如何执行一些更加抽象和模糊的任务
似乎指令微调的目标函数开始成为一个瓶颈
很难使用这种非常狭窄的信号来训练一个比GPT-4大上千倍的模型
那么
我们是否可以使用某种方式来替代这个最大似然目标呢？
这就是强化学习与RLHF的核心观点
在强化学习中
我们试图最大化一个预期的奖励函数
比方说一个代理在下棋，如果它赢了
我们给予它1的奖励，否则给予0
这就是一个有效的奖励函数
但是我们实际上可以使用一个模型
来为更复杂的情况定义奖励
我们称这个为奖励模型
我们都知道如何使用神经网络来进行监督式学习
因此
我们也可以使用神经网络来实现这个奖励模型
对于一个特定的输入
我们提供两个答案
并由人类来判断哪一个更受偏爱
而不是直接告诉模型哪一个是最好的
这样就为模型提供了一种学习人类偏好的方式
关键在于
尽管某个答案可能被视为首选
但是它并不一定是最佳选择
只要它比另一个选项好
模型就可以从中学习
比较的这种方法是至关重要的
为何我们选择比较而不是直接评分呢？
对于二加三这样的简单问题
认为五比四更好可能是没有意义的
因为只有一个正确答案
但是对于其他复杂的问题
比如某种句子的补全
我可能会提出两个较好的答案
并指出其中一个更为出色
核心思想是
比较可能比绝对评分更简单
具体来说，对于两个答案YI和YJ
我们定义了一个概率PIJ
表示答案I优于答案J的概率
这个概率是基于人类给出的标签
而概率模型实际上是基于奖励的差异
更具体地说，是对数几率
我们只需要重构这个模型并最大化这个概率
实际上就是在用最大似然法来训练奖励模型
在大型模型的最后阶段
目标函数是我们刚刚学到的
而奖励模型的参数在初始的强化学习阶段就已确定
这个方法可能会让你想起了生成对抗网络
其中有一个判别器和生成器
你固定其中的一部分参数
然后进行另一轮的迭代
这个策略模型通常是从监督指令微调的检查点开始的
你只需要为这个提示生成一些补全
然后提供给奖励模型
它就会返回一个得分
如果分数很低
那么我知道这个答案并不好
如果分数很高
那么我会尝试更多这样的答案
因此
这是数学中的一种试错方法的形式化表示
不过这只是一个宏观的观点
因为我们的目标是通过基于梯度的迭代方法来最大化这一目标
所以我们只需要梯度
这些梯度是通过一些策略级别的算法来获得的
比如PPO
核心思想是在满足RM模型的条件下进行迭代
在这个过程中
RM模型对人类的偏好进行编码
将其传递给策略模型
然后策略模型再通过强化学习来学习这些偏好
实际上
许多人并不是真的喜欢这种方法
包括OpenAI的人
主要的问题在于
实施这种方法确实很困难
强化学习是一个非常复杂的领域
很容易出错
一个常见的问题是所谓的“奖励黑客”。
如果模型发现长时间的完成
得到了更高的奖励
它可能会倾向于产生更长的答案
即使这些答案没有意义
这种模型的行为与人类的偏好是不一致的
这种差异被称为“奖励黑客”。
这是一个比较困难的问题
目前还没有明确的解决方案
尽管存在这些挑战
但是RLHF仍然是一个有价值的研究方向
因为最大似然的归纳偏差实在是太强了
当模型规模增加的时候
这种偏差可能会导致问题
学习这个目标函数可以帮助我们克服这种偏见
总的来说
如果某个方法在原则上是对的
我们就应该继续研究
直到我们找到正确的方法
最后，尚哥从高层次的视角
回顾了一下人工智能的发展
从基于规则的系统开始
输入是通过手工设计的程序来映射的
在下一代机器学习系统中
输入被转换为了手工设计的特征
然后通过一个可学习的部分来映射到输出
例如SVM
随后呢这些输入和输出
被传递给一个手工设计的损失函数
然后进行迭代
深度学习的主要变革呢
是将手工设计的特征
替换为学习到的特征
要特别指出的是
分层的表示学习
定义了深度学习的技术特点
这种转变确实取得了巨大的成功
为什么会这样呢
因为它采用了更弱的归纳偏差
并允许了更高的可扩展性
我们现在拥有更强大的计算能力
所以为什么不充分的利用它呢
这就是深度学习成功的核心
因此如果我们比较经典的机器学习和深度学习
最接近的对比可能是逻辑回归和前馈神经网络
他们处理相同的任务
但是前馈神经网络从数据中学习到了隐藏的表示
这就使得模型能够更好地处理二进制分类任务
那么下一个演进阶段会是什么呢
如果仅仅是改变一个组件让它变得可学习了
就可以如此的成功
那为什么不尝试更多的改变呢
目前损失函数仍然是通过手工来设计的
也许我们应该打破这个约束
让它也变得可学习
这或许就是下一个阶段
而且已经有了一些成功的例子
比如说GAN和RLHF
这些模型允许复杂的行为表达
而这些行为如果要被形式化的描述将会非常困难
尚哥相信
学习损失函数或者目标函数将是下一个范式
并且应该努力朝这个方向发展
好了
以上就是尚哥这次讲解的主要内容
其中有一些对Transformer和并行计算的详细讲解
由于时间关系呢大飞做了一些省略
有兴趣的同学呢可以去看原视频
大概一个多小时
最近呢大飞在帮朋友的项目跑融资啊
到处见投资人
所以呢确实是比较花精力的
于是也这个断更了比较长的时间
被大家开始催更了
所以呢在这里跟大家说一声抱歉
应该过了这周呢就会好很多了
感谢大家的关注和包容
本期视频内容就到这里我们下期再见
